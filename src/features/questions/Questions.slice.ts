import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';import { TStateBase } from 'src/types';import {  createReducersHandler,  toggleArray,} from 'src/utils';import {  IAddQuestionRequest,  IEditQuestionRequest,  TQuestion,} from 'src/features/questions/Questions.types';import { questionsApi } from 'src/api/questionsApi/questionsApi';interface QuestionsState extends TStateBase{  meta: {    fetching: boolean;    creating: boolean;    updating: boolean;    deleting: number[];  };  questions: TQuestion[];}const initialState: QuestionsState = {  status: 'idle',  message: '',  meta: {    fetching: false,    creating: false,    deleting: [],    updating: false,  },  questions: [],};const questionsSlice = createSlice({  name: 'questionsReducer',  initialState,  reducers: {    toggleDeleting: (state, { payload }: PayloadAction<number>) => {      state.meta.deleting = toggleArray(state.meta.deleting, payload);    },  },  extraReducers: (builder) => {    //READ    builder.addCase(fetchQuestionsAsync.pending, (state) => {      state.meta.fetching = true;    });    builder.addCase(fetchQuestionsAsync.rejected, (state) => {      state.meta.fetching = false;    });    builder.addCase(fetchQuestionsAsync.fulfilled, (state, { payload }) => {      state.questions = payload;      state.meta.fetching = false;    });    // CREATE    builder.addCase(createQuestionAsync.pending, (state) => {      state.meta.creating = true;    });    builder.addCase(createQuestionAsync.rejected, (state) => {      state.meta.creating = false;    });    builder.addCase(createQuestionAsync.fulfilled, (state) => {      state.meta.creating = false;      state.message = 'Вопрос успешно создан';    });    // UPDATE    builder.addCase(editQuestionAsync.pending, (state) => {      state.meta.updating = true;    });    builder.addCase(editQuestionAsync.rejected, (state) => {      state.meta.updating = false;    });    builder.addCase(editQuestionAsync.fulfilled, (state) => {      state.meta.updating = false;      state.message = 'Изменения успешно применены';    });    // DELETE    builder.addCase(deleteQuestionAsync.fulfilled, (state, { payload }) => {      state.questions = state.questions.filter((q) => q.id !== payload);    });    //OTHER    createReducersHandler(builder);  },});export const fetchQuestionsAsync = createAsyncThunk(  'questionsReducer/fetchQuestionsAsync',  async (_, { rejectWithValue }) => {    try {      const { data } = await questionsApi.fetchQuestions();      return data;    } catch (e: any) {      const msg = JSON.parse(e.request?.response)?.message;      return rejectWithValue(msg || e.message);    }  });export const editQuestionAsync = createAsyncThunk(  'questionsReducer/editQuestionAsync',  async (params: IEditQuestionRequest, { rejectWithValue }) => {    try {      const { data } = await questionsApi.updateQuestion(params);      return data;    } catch (e: any) {      const msg = JSON.parse(e.request?.response)?.message;      return rejectWithValue(msg || e.message);    }  });export const createQuestionAsync = createAsyncThunk(  'questionsReducer/createQuestionAsync',  async (params: IAddQuestionRequest, { rejectWithValue }) => {    try {      const { data } = await questionsApi.createQuestion(params);      return data;    } catch (e: any) {      const msg = JSON.parse(e.request?.response)?.message;      return rejectWithValue(msg || e.message);    }  });export const deleteQuestionAsync = createAsyncThunk(  'questionsReducer/deleteQuestionAsync',  async (id: number, { rejectWithValue, dispatch }) => {    try {      dispatch(questionsActions.toggleDeleting(id));      await questionsApi.deleteQuestion(id);      dispatch(questionsActions.toggleDeleting(id));      return id;    } catch (e: any) {      dispatch(questionsActions.toggleDeleting(id));      const msg = JSON.parse(e.request?.response)?.message;      return rejectWithValue(msg || e.message);    }  });export const { actions: questionsActions, reducer: questionsReducer } =  questionsSlice;