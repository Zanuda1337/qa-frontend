import {createAsyncThunk, createSlice, PayloadAction} from '@reduxjs/toolkit';import { TStateBase } from 'src/types';import {  createReducersHandler,} from 'src/utils';import { trainerApi } from 'src/api/trainerApi/trainerApi';import {ITrainerQuestion} from "src/features/trainer/Trainer.types";import {STORAGE_CATEGORY_PREFERENCES} from "src/consts";import {getCategoriesIdsFromStorage} from "src/features/trainer/Trainer.utils";interface TrainerState extends TStateBase {  categoriesIds: number[];  questions: ITrainerQuestion[];}const initialState: TrainerState = {  status: 'idle',  message: '',  categoriesIds: getCategoriesIdsFromStorage(),  questions: [],};const trainerSlice = createSlice({  name: 'trainerReducer',  initialState,  reducers: {    setCategories: (state, {payload}: PayloadAction<number[]>) => {      state.categoriesIds = payload;    },    selectCategory: (state, action: PayloadAction<number>) => {      let newCategoriesIds = [...state.categoriesIds]      if(state.categoriesIds.includes(action.payload)) {        newCategoriesIds = state.categoriesIds.filter(id => id !== action.payload)      }      else newCategoriesIds.push(action.payload);      state.categoriesIds = newCategoriesIds;      localStorage.setItem(STORAGE_CATEGORY_PREFERENCES, JSON.stringify(newCategoriesIds));    },    nextQuestion: state => {      state.questions.shift();    }  },  extraReducers: (builder) => {    builder.addCase(fetchNewQuestionsAsync.fulfilled, (state, { payload }) => {      state.questions = payload;      state.categoriesIds = []    });    builder.addCase(fetchRepeatQuestionsAsync.fulfilled, (state, { payload }) => {      state.questions = payload;      state.categoriesIds = []    });    builder.addCase(fetchCompoQuestionsAsync.fulfilled, (state, { payload }) => {      state.questions = payload;      state.categoriesIds = []    });    createReducersHandler(builder)  },});export const fetchNewQuestionsAsync = createAsyncThunk(  'trainerReducer/fetchNewQuestionsAsync',  async (    { categoriesIds }: { categoriesIds: number[] },    { rejectWithValue }  ) => {    try {      const { data } = await trainerApi.fetchNewQuestions(categoriesIds);      return data;    } catch (e: any) {      const msg = JSON.parse(e.request?.response)?.message;      return rejectWithValue(msg || e.message);    }  });export const fetchRepeatQuestionsAsync = createAsyncThunk(  'trainerReducer/fetchRepeatQuestionsAsync',  async (    { categoriesIds }: { categoriesIds: number[] },    { rejectWithValue }  ) => {    try {      const { data } = await trainerApi.fetchRepeatQuestions(categoriesIds);      return data;    } catch (e: any) {      const msg = JSON.parse(e.request?.response)?.message;      return rejectWithValue(msg || e.message);    }  });export const fetchCompoQuestionsAsync = createAsyncThunk(  'trainerReducer/fetchCompoQuestionsAsync',  async (    { categoriesIds }: { categoriesIds: number[] },    { rejectWithValue }  ) => {    try {      const { data } = await trainerApi.fetchCompoQuestions(categoriesIds);      return data;    } catch (e: any) {      const msg = JSON.parse(e.request?.response)?.message;      return rejectWithValue(msg || e.message);    }  });export const reportQuestionAsync = createAsyncThunk(  'trainerReducer/reportQuestionAsync',  async (    { id, correct }: { id: number, correct: boolean },    { rejectWithValue, dispatch }  ) => {    try {      await trainerApi.reportQuestion(id, correct);      dispatch(trainerActions.nextQuestion());    } catch (e: any) {      const msg = JSON.parse(e.request?.response)?.message;      return rejectWithValue(msg || e.message);    }  });export const { actions: trainerActions, reducer: trainerReducer } =  trainerSlice;