import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';import { TStateBase } from 'src/types';import { createReducersHandler, toggleArray } from 'src/utils';import {  TAddCategoryRequest,  TCategory,  TEditCategoryRequest,} from 'src/features/categories/Categories.types';import { categoriesApi } from 'src/api/categoriesApi/categoriesApi';import { trainerApi } from 'src/api/trainerApi/trainerApi';interface CategoriesState extends TStateBase {  categories: TCategory[];  meta: {    creating: boolean;    updating: number[];    fetching: boolean;    deleting: number[];  };}const initialState: CategoriesState = {  status: 'idle',  message: '',  categories: [],  meta: {    creating: false,    fetching: false,    updating: [],    deleting: [],  },};const categoriesSlice = createSlice({  name: 'categoriesReducer',  initialState,  reducers: {    toggleDeleting: (state, { payload }: PayloadAction<number>) => {      state.meta.deleting = toggleArray(state.meta.deleting, payload);    },    toggleUpdating: (state, { payload }: PayloadAction<number>) => {      state.meta.updating = toggleArray(state.meta.updating, payload);    },  },  extraReducers: (builder) => {    //READ    builder.addCase(fetchCategoriesAsync.pending, (state) => {      state.meta.fetching = true;    });    builder.addCase(fetchCategoriesAsync.rejected, (state) => {      state.meta.fetching = false;    });    builder.addCase(fetchCategoriesAsync.fulfilled, (state, { payload }) => {      state.categories = payload;      state.meta.fetching = false;    });    // CREATE    builder.addCase(createCategoryAsync.pending, (state) => {      state.meta.creating = true;    });    builder.addCase(createCategoryAsync.rejected, (state) => {      state.meta.creating = false;    });    builder.addCase(createCategoryAsync.fulfilled, (state, { payload }) => {      state.message = 'Категория успешно создана';      state.meta.creating = false;      state.categories.push(payload)    });    // UPDATE    builder.addCase(editCategoryAsync.fulfilled, (state, { payload }) => {      state.message = 'Изменения успешно применены';      state.categories = state.categories.map((c) =>        c.id === payload.id ? payload : c      );    });    // DELETE    builder.addCase(deleteCategoryAsync.fulfilled, (state, { payload }) => {      state.categories = state.categories.filter((c) => c.id !== payload);    });    //OTHER    builder.addCase(      resetCategoryProgressAsync.fulfilled,      (state, { payload }) => {        state.categories = state.categories.map((category) =>          payload === category.id            ? {                ...category,                questionsCount: {                  ...category.questionsCount,                  learned: 0,                  mastered: 0,                  total: category?.questionsCount?.total || 0,                },              }            : category        );      }    );    createReducersHandler(builder);  },});export const fetchCategoriesAsync = createAsyncThunk(  'categoriesReducer/fetchCategoriesAsync',  async (    { withQuestions }: { withQuestions: boolean },    { rejectWithValue }  ) => {    try {      const { data } = await categoriesApi.fetchCategories(withQuestions);      return data;    } catch (e: any) {      const msg = JSON.parse(e.request?.response)?.message;      return rejectWithValue(msg || e.message);    }  });export const resetCategoryProgressAsync = createAsyncThunk(  'categoriesReducer/resetCategoryProgressAsync',  async ({ id }: { id: number }, { rejectWithValue }) => {    try {      await trainerApi.resetCategoryProgress(id);      return id;    } catch (e: any) {      const msg = JSON.parse(e.request?.response)?.message;      return rejectWithValue(msg || e.message);    }  });export const createCategoryAsync = createAsyncThunk(  'categoriesReducer/createCategoryAsync',  async (params: TAddCategoryRequest, { rejectWithValue }) => {    try {      const { data } = await categoriesApi.createCategory(params);      return data;    } catch (e: any) {      const msg = JSON.parse(e.request?.response)?.message;      return rejectWithValue(msg || e.message);    }  });export const editCategoryAsync = createAsyncThunk(  'categoriesReducer/editCategoryAsync',  async (params: TEditCategoryRequest, { rejectWithValue, dispatch }) => {    try {      dispatch(categoriesActions.toggleUpdating(params.id));      const { data } = await categoriesApi.editCategory(params);      dispatch(categoriesActions.toggleUpdating(params.id));      return data;    } catch (e: any) {      dispatch(categoriesActions.toggleUpdating(params.id));      const msg = JSON.parse(e.request?.response)?.message;      return rejectWithValue(msg || e.message);    }  });export const deleteCategoryAsync = createAsyncThunk(  'categoriesReducer/deleteCategoryAsync',  async (id: number, { rejectWithValue, dispatch }) => {    try {      dispatch(categoriesActions.toggleDeleting(id));      await categoriesApi.deleteCategory(id);      dispatch(categoriesActions.toggleDeleting(id));      return id;    } catch (e: any) {      dispatch(categoriesActions.toggleDeleting(id));      const msg = JSON.parse(e.request?.response)?.message;      return rejectWithValue(msg || e.message);    }  });export const { actions: categoriesActions, reducer: categoriesReducer } =  categoriesSlice;