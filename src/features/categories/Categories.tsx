import React, { useEffect, useState } from 'react';import { useAppSelector, useBoundActions } from 'src/app/hooks';import { useScreen, useSnackbarListener } from 'src/hooks';import {  DataGrid,  GridActionsCellItem,  GridColDef,  GridEventListener,  GridRowEditStopReasons,  GridRowId,  GridRowModel,  GridRowModes,  GridRowModesModel,  GridRowsProp,} from '@mui/x-data-grid';import {  createCategoryAsync,  deleteCategoryAsync,  editCategoryAsync,  fetchCategoriesAsync,} from 'src/features/categories/Categories.slice';import { Button } from '@mui/material';import SvgSelector from 'src/components/SvgSelector/SvgSelector';import WithLoading from 'src/components/WithLoading/WithLoading';import CustomNoRowsOverlay from 'src/components/AdminTable/CustomNoRowsOverlay';import classes from 'src/components/AdminTable/AdminTable.module.scss';import CustomDialogue from 'src/components/CustomDialogue/CustomDialogue';const allActions = {  fetchCategoriesAsync,  deleteCategoryAsync,  createCategoryAsync,  editCategoryAsync,};const Categories: React.FC = () => {  const categories = useAppSelector(    (state) => state.categoriesReducer.categories  );  const meta = useAppSelector((state) => state.categoriesReducer.meta);  const status = useAppSelector((state) => state.categoriesReducer.status);  const message = useAppSelector((state) => state.categoriesReducer.message);  const boundActions = useBoundActions(allActions);  const { width } = useScreen();  const [deleteCandidate, setDeleteCandidate] = useState<number | null>(null);  const [modalOpen, setModalOpen] = useState(false);  useEffect(() => {    boundActions.fetchCategoriesAsync({ withQuestions: false });  }, []);  useEffect(() => {    setRows(categories);  }, [categories]);  useSnackbarListener(message, status === 'failed' ? 'error' : 'info');  const [rowModesModel, setRowModesModel] = React.useState<GridRowModesModel>(    {}  );  const [rows, setRows] = React.useState<GridRowsProp>(categories);  const handleRowEditStop: GridEventListener<'rowEditStop'> = (    params,    event  ) => {    if (params.reason === GridRowEditStopReasons.rowFocusOut) {      event.defaultMuiPrevented = true;    }  };  const handleEditClick = (id: GridRowId) => () => {    setRowModesModel({ ...rowModesModel, [id]: { mode: GridRowModes.Edit } });  };  const handleSaveClick = (id: GridRowId) => async () => {    setRowModesModel({ ...rowModesModel, [id]: { mode: GridRowModes.View } });  };  const handleDeleteClick = (id: GridRowId) => () => {    setDeleteCandidate(id as number);    setModalOpen(true);  };  const handleCloseModal = () => {    setModalOpen(false);    setDeleteCandidate(null);  };  const handleDeleteRow = () => {    if (!deleteCandidate) return;    boundActions      .deleteCategoryAsync(deleteCandidate)      .unwrap()      .then(handleCloseModal);  };  const handleCancelClick = (id: GridRowId) => () => {    setRowModesModel({      ...rowModesModel,      [id]: { mode: GridRowModes.View, ignoreModifications: true },    });    const editedRow = rows.find((row) => row.id === id);    if (editedRow!.isNew) {      setRows(rows.filter((row) => row.id !== id));    }  };  const processRowUpdate = async (newRow: GridRowModel) => {    const updatedRow = { ...newRow, isNew: false };    if (newRow.isNew) {      await boundActions.createCategoryAsync({ name: newRow.name });    } else {      await boundActions.editCategoryAsync({        id: newRow.id,        name: newRow.name,      });    }    return updatedRow;  };  const handleRowModesModelChange = (newRowModesModel: GridRowModesModel) => {    setRowModesModel(newRowModesModel);  };  const columns: GridColDef[] = [    { field: 'id', headerName: 'ID', width: 30, type: 'number' },    {      field: 'name',      headerName: 'Тема вопроса',      flex: 1,      editable: true,    },    {      field: 'actions',      type: 'actions',      headerName: 'Действия',      width: 100,      cellClassName: 'actions',      getActions: ({ id }) => {        const isInEditMode = rowModesModel[id]?.mode === GridRowModes.Edit;        const isUpdating = meta.updating.includes(id as number);        const isDeleting = meta.deleting.includes(id as number);        if (isInEditMode) {          return [            <GridActionsCellItem              icon={<SvgSelector id="save" className={'actionIcon save'} />}              label="Save"              onClick={handleSaveClick(id)}            />,            <GridActionsCellItem              icon={<SvgSelector id="close" className={'actionIcon'} />}              label="Cancel"              onClick={handleCancelClick(id)}              color="inherit"            />,          ];        }        return [          <WithLoading fetching={isUpdating} size={30}>            <GridActionsCellItem              icon={<SvgSelector id="edit" className={'actionIcon'} />}              label="Edit"              disabled={isUpdating || isDeleting}              onClick={handleEditClick(id)}              color="inherit"            />          </WithLoading>,          <WithLoading fetching={isDeleting} size={30}>            <GridActionsCellItem              disabled={isUpdating || isDeleting}              icon={<SvgSelector id="delete" className={'actionIcon'} />}              label="Delete"              onClick={handleDeleteClick(id)}              color="inherit"            />          </WithLoading>,        ];      },    },  ];  return (    <div className={'admin'}>      <CustomDialogue        open={modalOpen}        content={          'Все вопросы, входящие в данную категорию, также будут удалены. Это действие нельзя будет отменить.'        }        title={'Вы уверены?'}        onClose={handleCloseModal}        onConfirm={handleDeleteRow}        fetching={!!meta.deleting.length}      />      <DataGrid        rows={rows}        columns={columns}        loading={meta.fetching || meta.creating}        editMode="row"        className={'table'}        rowModesModel={rowModesModel}        onRowModesModelChange={handleRowModesModelChange}        onRowEditStop={handleRowEditStop}        processRowUpdate={processRowUpdate}        hideFooter        autoHeight        density={width >= 500 ? 'standard' : 'compact'}        sx={{ '--DataGrid-overlayHeight': '300px' }}        slots={{          noRowsOverlay: CustomNoRowsOverlay,          noResultsOverlay: CustomNoRowsOverlay,          toolbar: EditToolbar,        }}        slotProps={{          toolbar: { setRows, setRowModesModel },        }}      />    </div>  );};export default Categories;interface EditToolbarProps {  setRows: (newRows: (oldRows: GridRowsProp) => GridRowsProp) => void;  setRowModesModel: (    newModel: (oldModel: GridRowModesModel) => GridRowModesModel  ) => void;}function EditToolbar(props: EditToolbarProps) {  const { setRows, setRowModesModel } = props;  const handleClick = () => {    const id = '';    setRows((oldRows) => [...oldRows, { id, name: '', isNew: true }]);    setRowModesModel((oldModel) => ({      ...oldModel,      [id]: { mode: GridRowModes.Edit, fieldToFocus: 'name' },    }));  };  return (    <div>      <Button className={classes.addButton} onClick={handleClick}>        <p>+ Добавить</p>      </Button>    </div>  );}